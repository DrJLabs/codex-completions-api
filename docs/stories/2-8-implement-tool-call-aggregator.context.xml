<story-context id="codex-completions-api:stories:2-8-implement-tool-call-aggregator" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>8</storyId>
    <title>Implement ToolCallAggregator utility</title>
    <status>drafted</status>
    <generatedAt>2025-11-08T21:26:59Z</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/2-8-implement-tool-call-aggregator.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>backend developer</asA>
    <iWant>a pure ToolCallAggregator module that assembles Codex app-server tool/function call signals into OpenAI-compatible records</iWant>
    <soThat>streaming and non-streaming handlers can reuse one library to surface tool_calls/function_call payloads without duplicating parsing logic</soThat>
    <tasks>- Module implementation — build `src/lib/tool-call-aggregator.js` with per-choice maps keyed by backend call ids/ordinals, normalize Codex v2 + OpenAI delta/message shapes, emit name-first deltas with cumulative args, implement `ingestDelta`/`ingestMessage`/`snapshot`/`resetTurn`, and keep the module pure plus memory bounded. (AC #1-5, #7-20, #23)
- Textual fallback plugin — ship `extractUseToolBlocks()` and `registerTextPattern()` helpers for &lt;use_tool&gt; spans so textual detection can synthesize calls without mutating aggregator state directly. (AC #6)
- Unit tests — cover streaming/idempotency, multi-call ordering, choice isolation, textual fallback, non-stream snapshots, malformed args, mixed inputs, and reset semantics in `tests/unit/tool-call-aggregator.spec.js`. (AC #1-20)
- Documentation — author `docs/dev/tool-call-aggregator.md` with API/behavior examples plus handler boundaries so downstream teams can integrate without rework. (AC #2, #6, #10, #21)
- Obsidian XML helpers — add `src/lib/tools/obsidianToolsSpec.ts` plus XML escape utilities so snapshots emit ordered parameters for Obsidian Copilot. (AC #21-24)</tasks>
  </story>

  <acceptanceCriteria>1. Streaming partials — `ingestDelta()` emits `ToolCallDelta` entries as soon as a function name arrives and keeps updating the same id as argument chunks stream in. (docs/codex-proxy-tool-calls.md#streaming-detection--flow)
2. Final snapshot — `snapshot()` returns `ToolCallRecord[]` with best-effort argument text for every detected call so non-stream handlers can build responses. (docs/codex-proxy-tool-calls.md#non-streaming-detection--flow)
3. Single vs multi forms — aggregator data surfaces both `tool_calls[]` arrays and legacy `function_call` objects without extra transforms. (docs/codex-proxy-tool-calls.md#finish-reason-and-message-semantics)
4. Multi-call ordering — multiple calls per choice preserve creation order with distinct ids. (docs/codex-proxy-tool-calls.md#behavioral-notes)
5. Choice-aware state — all APIs accept `choiceIndex`, isolate buffers per choice, and `resetTurn()` resets that scope. (docs/codex-proxy-tool-calls.md#behavioral-notes)
6. Textual fallback — built-in &lt;use_tool&gt; parser plus `registerTextPattern()` expose `{indexStart,indexEnd,name,argsText}` for textual detection. (docs/codex-proxy-tool-calls.md#textual-fallback-detection)
7. Robustness — interleaved/unknown deltas never throw; malformed JSON fragments are tolerated; buffers stay bounded and cleared on reset. (docs/codex-proxy-tool-calls.md#risks--mitigations)
8. Purity — module has no side effects (logging, telemetry, finish-reason selection, or process control). (docs/codex-proxy-tool-calls.md#behavioral-notes)
9. ID stability — call ids follow `tool_&lt;choiceIndex&gt;_&lt;ordinal&gt;[_&lt;shortRand&gt;]` and stay stable within a turn. (docs/codex-proxy-tool-calls.md#behavioral-notes)
10. Tests — unit suite covers streaming permutations, textual fallback, mixed shapes, malformed arguments, and reset semantics. (docs/codex-proxy-tool-calls.md#acceptance-criteria)
11. Idempotent deltas — re-ingesting identical events yields `updated:false` and no new deltas. (docs/codex-proxy-tool-calls.md#acceptance-criteria)
12. Name-first emission — once the function name is known, emit a delta immediately with the stable id and cumulative arguments. (docs/codex-proxy-tool-calls.md#behavioral-notes)
13. No cross-call interleaving — argument chunks stay bound to their originating call id or ordinal. (docs/codex-proxy-tool-calls.md#behavioral-notes)
14. Do not parse JSON — aggregator concatenates argument text verbatim without parsing/validating JSON. (docs/codex-proxy-tool-calls.md#behavioral-notes)
15. Snapshot ordering — `snapshot()` returns calls in creation order per choice until `resetTurn()` runs. (docs/codex-proxy-tool-calls.md#behavioral-notes)
16. Duplicate/unknown events tolerance — duplicate creations, missing done signals, and irrelevant deltas are ignored safely without corrupting state. (docs/codex-proxy-tool-calls.md#behavioral-notes)
17. Cumulative arguments in deltas — each emitted delta returns the cumulative argument string gathered so far. (docs/codex-proxy-tool-calls.md#behavioral-notes)
18. Input shape tolerance — APIs accept Codex app-server v2 events plus OpenAI-native `delta.function_call`/`message.tool_calls` payloads. (docs/codex-proxy-tool-calls.md#behavioral-notes)
19. Immutable outputs — results from `ingestDelta()` and `snapshot()` are deep-copied so callers cannot mutate internal state. (docs/codex-proxy-tool-calls.md#behavioral-notes)
20. resetTurn semantics — `resetTurn()` clears per-choice buffers while preserving registered textual patterns for reuse. (docs/codex-proxy-tool-calls.md#behavioral-notes)
21. Obsidian XML synthesis — snapshots expose enough data to render canonical &lt;use_tool&gt; blocks for Obsidian Copilot without re-parsing. (docs/epics.md#story-28-implement-toolcallaggregator-utility)
22. Parameter canon mapping — argument shaping enforces ordered, known tool parameters and drops unknown keys while keeping raw JSON text. (docs/epics.md#story-28-implement-toolcallaggregator-utility)
23. Argument shaping for helpers — aggregator (or sibling utility) drops unknown keys yet preserves raw JSON strings needed for downstream XML helpers. (docs/PRD.md#functional-requirements)
24. XML rendering safety — XML helpers escape scalars and serialize arrays per Copilot spec so generated &lt;use_tool&gt; content stays valid. (docs/app-server-migration/codex-completions-api-migration.md; docs/Integrating Codex Proxy with Obsidian Copilot for Tool Calls.md)</acceptanceCriteria>

  <artifacts>
    <docs>- docs/codex-proxy-tool-calls.md — Implementation guide defining aggregator scope, textual fallback strategy, API contract, and handler responsibilities.
- docs/epics.md#story-28-implement-toolcallaggregator-utility — Epic 2 narrative plus acceptance criteria tying this story to handler parity and Obsidian XML helpers.
- docs/PRD.md#functional-requirements — FR002/FR002a mandate OpenAI-compatible tool_call semantics, immutable outputs, and Obsidian-ready XML helpers.
- docs/tech-spec-epic-2.md#detailed-design — JSON-RPC schema bindings, transport adapters, and handler responsibilities the aggregator plugs into.
- docs/test-design-epic-2.md — Risk register (R-101/R-102) and coverage matrix specifying unit, integration, Playwright, and smoke expectations for tool-call behavior.</docs>
    <code>- src/lib/tool-call-aggregator.js#L1-L210 — Current implementation that ingests `tool_calls` arrays, normalizes ids, and snapshots cumulative arguments; will be extended for textual fallback, per-choice resets, and immutable outputs.
- tests/unit/tool-call-aggregator.spec.js#L1-L70 — Existing Vitest coverage for basic delta/snapshot flows; expand into the structured/textual/idempotent matrix called for by docs/test-design-epic-2.md.
- src/handlers/chat/stream.js#L800-L1820 — Streaming handler already instantiates `createToolCallAggregator()` and scans for &lt;use_tool&gt;, making it the primary integration point for new delta APIs and XML helpers.
- src/handlers/chat/nonstream.js#L450-L1050 — Non-stream handler accumulates final messages, textual fallbacks, and emits `tool_calls` / `<use_tool>` content; snapshots from the upgraded aggregator flow directly into these paths.
- src/lib/json-rpc/schema.ts#L520-L620 — Typed definitions for `AgentMessageDelta` / `AgentMessage` notifications (including `tool_calls`, `function_call`, `parallel_tool_calls` flags) that the aggregator must map without schema drift.
- src/dev-logging.js#L160-L208 — `extractUseToolBlocks()` parser used today for textual detection; consolidating this logic with aggregator-managed patterns prevents duplicated regex/JSON parsing.</code>
    <dependencies>- package.json (runtime) — `@openai/codex@0.56.0` delivers the CLI/app-server binary and JSON-RPC schema that emit the structured tool events consumed by the aggregator.
- package.json (runtime) — `express@^4.21.2` and shared middleware keep `/v1/chat/completions` handlers stable while the aggregator injects tool_call payloads.
- package.json (runtime) — `nanoid@^5.1.6` already powers id generation inside `createToolCallAggregator()`; ensure new helpers keep ids deterministic per choice.
- package.json (dev/test) — `vitest@^4.0.3` + `@playwright/test@^1.56.1` supply the unit/integration/E2E harnesses referenced by docs/test-design-epic-2.md for tool-call parity.
- scripts/smoke/stream-tool-call.js — CLI smoke harness that exercises streaming tool-call flows end-to-end, providing fast regressions for structured/textual cases.</dependencies>
  </artifacts>

  <constraints>- Aggregator must remain a pure `src/lib` utility with no logging/telemetry or finish-reason coupling, per docs/codex-proxy-tool-calls.md scope.
- Implementation must preserve architecture structure (logic in `src/lib`, tests mirrored under `tests/unit`) and follow the repo’s naming/formatting conventions in docs/architecture.md#implementation-patterns.
- Textual fallback detection and Obsidian XML serialization have to reuse shared helpers so handler stories (2.9/2.10) do not duplicate parsing/escaping rules. (docs/epics.md#story-28-implement-toolcallaggregator-utility; docs/app-server-migration/codex-completions-api-migration.md)
- Structured input coverage must embrace both Codex JSON-RPC notifications and OpenAI-native payloads without schema drift, leveraging `src/lib/json-rpc/schema.ts`. (docs/tech-spec-epic-2.md)
- Output must stay OpenAI-compatible while also supplying `<use_tool>` blocks for Obsidian mode, so aggregator snapshots need to support both envelopes simultaneously. (docs/Integrating Codex Proxy with Obsidian Copilot for Tool Calls.md)</constraints>
  <interfaces>- `createToolCallAggregator()` (`src/lib/tool-call-aggregator.js`) — exposes `ingestDelta`, `ingestMessage`, `snapshot`, `resetTurn`, and `supportsParallelCalls()` for handlers; new helpers (textual patterns, XML serialization) extend this interface.
- JSON-RPC notifications (`AgentMessageDeltaNotification`, `AgentMessageNotification` in `src/lib/json-rpc/schema.ts`) — structured tool/function events the aggregator must normalize without losing ids, names, or parallel-call flags.
- `extractUseToolBlocks(text, startAt)` (`src/dev-logging.js`) — existing parser for textual `<use_tool>` spans; aggregator should orchestrate this helper (plus new registries) rather than introducing divergent regex logic.</interfaces>
  <tests>
    <standards>Follow docs/test-design-epic-2.md: expand the unit matrix for structured/textual/idempotent scenarios (R-101), add integration + Playwright flows that assert role-first SSE ordering and finish_reason semantics (R-102), and keep smoke jobs publishing transcripts/logs for tool-call regressions.</standards>
    <locations>tests/unit/tool-call-aggregator.spec.js; tests/integration/chat-jsonrpc.int.test.js; tests/e2e/**/tool-calls*.spec.ts; scripts/smoke/stream-tool-call.js; scripts/dev-smoke.sh; scripts/prod-smoke.sh</locations>
    <ideas>- AC#1/#12/#17 — Table-driven unit cases feeding Codex delta fixtures (name-first, chunked args, duplicates) to assert cumulative arguments, stable ids, and idempotent updates.
- AC#6/#21/#24 — Textual fallback tests that parse multiple &lt;use_tool&gt; blocks with noise, verify synthesized records match `toObsidianXml()` output, and ensure XML escaping for arrays/scalars.
- AC#2/#3/#5/#15 — Integration spec wiring the aggregator into chat handlers (structured + textual) to confirm snapshots drive both `tool_calls[]` metadata and `<use_tool>` content across multiple choices and output modes.</ideas>
  </tests>
</story-context>
