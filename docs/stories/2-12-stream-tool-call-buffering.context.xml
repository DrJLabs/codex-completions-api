<story-context id="{bmad_folder}/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>12</storyId>
    <title>Story 2.12: Stream tool-call buffering for Obsidian mode</title>
    <status>drafted</status>
    <generatedAt>2025-11-19T03:56:20Z</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/2-12-stream-tool-call-buffering.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>As an application developer,</asA>
    <iWant>I want the streaming chat handler to buffer textual `<use_tool>` segments until each XML block closes,</iWant>
    <soThat>so that Obsidian-mode clients only see a single canonical tool invocation while structured `tool_calls[]` deltas and finish-reason semantics stay aligned with JSON-RPC parity goals.</soThat>
    <tasks><list>
  <item>
    <title>Implement per-choice buffering state (AC1)</title>
    <subtask>Extend `appendContentSegment()` in `src/handlers/chat/stream.js` to track `activeToolBuffer` per choice, halting SSE writes for that choice until `&lt;/use_tool&gt;` arrives. _[Source: docs/tool-call-buffering-brief.md#Proposed-Fix]_</subtask>
    <subtask>Ensure the buffered XML flows through the existing sanitizer before calling `emitToolContentChunk()` so aggregator/finish helpers receive the canonical content exactly once. _[Source: docs/codex-proxy-tool-calls.md#textual-fallback-detection]_</subtask>
  </item>
  <item>
    <title>Add guardrails + fallbacks (AC2–AC3)</title>
    <subtask>Detect nested `&lt;use_tool&gt;` markers or malformed XML, log structured warnings, flush the best-effort payload, and restart buffering to avoid deadlocks. _[Source: docs/tool-call-buffering-brief.md#Proposed-Fix]_</subtask>
    <subtask>Flush partial buffers when the backend disconnects or when `PROXY_KILL_ON_DISCONNECT` ends a stream, ensuring clients still see whatever Codex produced. _[Source: docs/architecture.md#implementation-patterns]_</subtask>
  </item>
  <item>
    <title>Telemetry + documentation updates (AC4)</title>
    <subtask>Emit `tool_buffer_started/flushed/aborted` counters (and optional debug logs) via `src/services/metrics/chat.js` or the existing SSE metrics helper, wiring them into observability dashboards. _[Source: docs/tool-call-buffering-brief.md#Risks--Considerations]_</subtask>
    <subtask>Update `docs/tool-call-buffering-brief.md`, `docs/tech-spec-epic-2.md`, and `docs/test-design-epic-2.md` to describe the buffering path, telemetry expectations, and risk-treatment plan R-107. _[Source: docs/test-design-epic-2.md#risk-register]_</subtask>
  </item>
  <item>
    <title>Regression tests + fixtures (AC5)</title>
    <subtask>Add unit tests for the buffering helper covering multi-chunk XML, nested blocks, truncated payloads, and sanitizer passthrough. _[Source: docs/tool-call-buffering-brief.md#Testing]_</subtask>
    <subtask>Create deterministic integration + Playwright fixtures that replay `.codev/proto-events.ndjson` request `HevrLsVQESL3K1M3_3dHi`, proving textual `&lt;use_tool&gt;` blocks appear once even when SSE chunks split mid-tag and when the stream aborts before `&lt;/use_tool&gt;`. _[Source: docs/tool-call-buffering-brief.md#Context]_ _[Source: docs/test-design-epic-2.md#risk-register]_</subtask>
  </item>
</list></tasks>
  </story>

  <acceptanceCriteria><list>
  <criterion id="AC1">**Per-choice buffering lifecycle.** `src/handlers/chat/stream.js` tracks an `activeToolBuffer` per choice: the handler pauses outbound SSE emission for that choice once it detects `&lt;use_tool` outside an active buffer, accumulates subsequent characters until the matching `&lt;/use_tool&gt;` arrives, then routes the sanitized XML through `emitToolContentChunk()` exactly once before clearing the buffer, ensuring aggregator + SSE output never duplicate textual blocks. _[Source: docs/epics.md#story-212-stream-tool-call-buffering-for-obsidian-mode]_ _[Source: docs/tool-call-buffering-brief.md#Proposed-Fix]_ _[Source: docs/codex-proxy-tool-calls.md#streaming-detection--flow]_</criterion>
  <criterion id="AC2">**Resiliency, fallbacks, and disconnect handling.** Buffering logic detects nested `&lt;use_tool&gt;` markers, malformed XML, or backend disconnects: it logs structured warnings, flushes the current buffer verbatim as a best-effort payload, restarts buffering if another opener appears, and guarantees cleanup flushes partially buffered content during client disconnects so no tool output is silently lost. _[Source: docs/tool-call-buffering-brief.md#Proposed-Fix]_ _[Source: docs/architecture.md#implementation-patterns]_</criterion>
  <criterion id="AC3">**Sanitization + aggregator alignment.** Buffered text continues to flow through the existing metadata sanitizer/telemetry pipeline prior to emission, honors `PROXY_STOP_AFTER_TOOLS(*)`, and keeps the ToolCallAggregator snapshots immutable—structured `tool_calls[]` deltas and finish-reason helpers behave identically before and after buffering. _[Source: docs/tech-spec-epic-2.md#story-212-stream-tool-call-buffering]_ _[Source: docs/codex-proxy-tool-calls.md#finish-reason-and-message-semantics]_</criterion>
  <criterion id="AC4">**Instrumentation + documentation.** Add lightweight metrics/telemetry counters (e.g., `tool_buffer_started`, `tool_buffer_flushed`, `tool_buffer_aborted`) surfaced via `src/services/metrics/chat.js` (or equivalent) plus logging breadcrumbs so operators can detect anomalies, and update `docs/tool-call-buffering-brief.md`, `docs/tech-spec-epic-2.md`, and `docs/test-design-epic-2.md` (risk R-107) with the buffering design + verification plan. _[Source: docs/tool-call-buffering-brief.md#Risks--Considerations]_ _[Source: docs/test-design-epic-2.md#risk-register]_</criterion>
  <criterion id="AC5">**Regression coverage.** Provide unit tests for the buffering helper (fragmented XML, nested markers, truncated payloads), an integration test that replays `.codev/proto-events.ndjson` request `HevrLsVQESL3K1M3_3dHi` to assert a single textual `&lt;use_tool&gt;` SSE frame, and an E2E/Playwright regression confirming Obsidian-mode clients never receive duplicate tool blocks even when textual XML spans multiple chunks or the stream aborts mid-block. _[Source: docs/tool-call-buffering-brief.md#Testing]_ _[Source: docs/test-design-epic-2.md#risk-register]_</criterion>
</list></acceptanceCriteria>

  <artifacts>
    <docs>  <doc>
    <path>docs/tool-call-buffering-brief.md</path>
    <title>Streaming Tool-Call Buffering Brief</title>
    <section>Context</section>
    <snippet>Problem: Obsidian-mode streaming currently emits textual &lt;use_tool&gt; blocks twice (request HevrLsVQESL3K1M3_3dHi), because appendContentSegment streams raw XML before emitToolContentChunk runs.</snippet>
  </doc>
  <doc>
    <path>docs/tech-spec-epic-2.md</path>
    <title>Tech Spec – Epic 2</title>
    <section>Story 2.12</section>
    <snippet>Spec states each choice keeps an activeToolBuffer, paused emission resumes only after &lt;/use_tool&gt;, and telemetry counters tool_buffer_started/flushed/aborted expose behavior.</snippet>
  </doc>
  <doc>
    <path>docs/epics.md</path>
    <title>Epics</title>
    <section>Story 2.12</section>
    <snippet>Epic outlines per-choice buffering, malformed XML fallbacks, telemetry counters, and regression fixtures replaying HevrLsVQESL3K1M3_3dHi.</snippet>
  </doc>
  <doc>
    <path>docs/codex-proxy-tool-calls.md</path>
    <title>Codex Proxy Tool Calls</title>
    <section>Streaming Detection &amp; Flow</section>
    <snippet>Documents how the streaming handler halts assistant output when tool calls start, feeds ToolCallAggregator deltas, and emits role-first SSE chunks with finish_reason=&quot;tool_calls&quot;.</snippet>
  </doc>
  <doc>
    <path>docs/architecture.md</path>
    <title>Decision Architecture</title>
    <section>Integration Patterns</section>
    <snippet>Integration points tie JSON-RPC transport, SSE gateway (`src/handlers/chat/stream.js`), and lifecycle telemetry so buffering must stay inside the streaming handler.</snippet>
  </doc>
  <doc>
    <path>docs/test-design-epic-2.md</path>
    <title>Test Design – Epic 2</title>
    <section>Risk Register R-107</section>
    <snippet>Risk R-107 flags duplicate textual &lt;use_tool&gt; blocks and mandates buffering logic plus unit/integration/Playwright fixtures asserting single emission.</snippet>
  </doc>
  <doc>
    <path>docs/stories/2-11-end-to-end-tracing.md</path>
    <title>Story 2.11 Review Log</title>
    <section>Action Items</section>
    <snippet>Tracing follow-ups require appendUsage on every exit and logHttpRequest before API-key guards so buffering telemetry can be stitched across ingress, backend, and usage logs.</snippet>
  </doc></docs>
    <code>  <artifact>
    <path>src/handlers/chat/stream.js</path>
    <kind>handler</kind>
    <symbol>appendContentSegment</symbol>
    <lines>1187-1250</lines>
    <reason>Choice state tracks emitted text, scanPos, and forwardedUpTo; textual blocks detected by extractUseToolBlocks flow through emitToolContentChunk.</reason>
  </artifact>
  <artifact>
    <path>src/lib/tool-call-aggregator.js</path>
    <kind>library</kind>
    <symbol>extractUseToolBlocks</symbol>
    <lines>1-120</lines>
    <reason>Registers default &lt;use_tool&gt; matcher, parses nested tags, and exposes extractUseToolBlocks used by the streaming buffer.</reason>
  </artifact>
  <artifact>
    <path>tests/integration/chat.stream.tool-calls.int.test.js</path>
    <kind>integration-test</kind>
    <symbol>stream tool-call fixtures</symbol>
    <lines>1-200</lines>
    <reason>Suites replay Codex transcripts to assert SSE role ordering, finish_reason=tool_calls, and absence of duplicate textual XML.</reason>
  </artifact>
  <artifact>
    <path>scripts/dev/trace-by-req-id.js</path>
    <kind>tooling</kind>
    <symbol>trace-by-req-id CLI</symbol>
    <lines>1-120</lines>
    <reason>Stitches access-log, proto, and usage NDJSON so buffering telemetry (tool_buffer_* counters, SSE frames) can be correlated per req_id.</reason>
  </artifact></code>
    <dependencies>  <node>
    <package name="express" version="^4.21.2" purpose="HTTP routing layer for /v1/chat/completions" />
    <package name="@openai/codex" version="0.58.0" purpose="JSON-RPC adapter spawning Codex App Server" />
    <package name="nanoid" version="^5.1.6" purpose="req_id generation shared with tracing workflow" />
    <package name="@playwright/test" version="^1.56.1" purpose="E2E SSE regression harness for buffering checks" />
    <package name="vitest" version="^4.0.3" purpose="Unit/integration runner for buffering helper tests" />
  </node></dependencies>
  </artifacts>

  <constraints>  <rule>Keep buffering logic inside src/handlers/chat/stream.js next to finish-reason helpers so SSE and ToolCallAggregator stay aligned (docs/stories/2-12-stream-tool-call-buffering.md).</rule>
  <rule>Aggregator remains canonical; buffered XML must flow through emitToolContentChunk() once so structured tool_calls[] snapshots stay immutable (docs/codex-proxy-tool-calls.md).</rule>
  <rule>Maintain SSE invariants: role-first delta, stop-after-tools enforcement, and `[DONE]` timing defined in docs/architecture.md.</rule>
  <rule>Apply tracing guidance from Story 2-11 so tool_buffer_* counters and ingress usage logs keep the same req_id context.</rule></constraints>
  <interfaces>  <interface>
    <name>Streaming tool-call SSE chunk</name>
    <kind>SSE JSON</kind>
    <signature>{"choices":[{"delta":{"tool_calls":[{"id":"...","type":"function","function":{"name":"..."},"arguments":"..."}]},"finish_reason":null}]}</signature>
    <path>docs/codex-proxy-tool-calls.md#streaming-detection--flow</path>
  </interface>
  <interface>
    <name>ToolCallAggregator textual matcher</name>
    <kind>JS API</kind>
    <signature>extractUseToolBlocks(text, startAt) =&gt; { blocks, nextPos }</signature>
    <path>src/lib/tool-call-aggregator.js</path>
  </interface></interfaces>
  <tests>
    <standards>Vitest covers buffering helpers and JSON-RPC transport, while Playwright verifies Obsidian-mode SSE contracts; follow docs/test-design-epic-2.md and story Dev Notes to record req_id traces plus metrics snapshots for tool_buffer_* counters.</standards>
    <locations>tests/unit/**/*.spec.js; tests/integration/**/tool*.int.test.js; playwright/tests/**/*.spec.ts; scripts/dev/trace-by-req-id.js outputs for req-based verification</locations>
    <ideas>  <idea ac="AC1">Unit-test appendContentSegment with multi-chunk textual blocks to ensure buffered literal emits exactly once and forwardedUpTo advances.</idea>
  <idea ac="AC2">Simulate malformed or truncated <use_tool> XML to assert warnings plus cleanup flush during disconnect events.</idea>
  <idea ac="AC3">Validate sanitized payload still flows through emitToolContentChunk() by spying on metadata sanitizer in Vitest.</idea>
  <idea ac="AC4">Integration test increments tool_buffer_started/flushed counters via metrics snapshot after streaming fixture HevrLsVQESL3K1M3_3dHi.</idea>
  <idea ac="AC5">Playwright SSE regression ensures Obsidian client receives one textual block even when SSE chunks split mid-tag.</idea></ideas>
  </tests>
</story-context>
