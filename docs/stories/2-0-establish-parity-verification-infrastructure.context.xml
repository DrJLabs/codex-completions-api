<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>0</storyId>
    <title>Establish Parity Verification Infrastructure</title>
    <status>ready-for-dev</status>
    <generatedAt>2025-10-31T22:30:41Z</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/2-0-establish-parity-verification-infrastructure.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>QA engineer</asA>
    <iWant>deterministic proto/app-server parity fixtures and an automated diff harness ready before feature work</iWant>
    <soThat>Epic 2 development has fast, trustworthy regression feedback</soThat>
    <tasks>- [ ] (AC #1) Extend transcript capture scripts to emit paired proto/app fixtures
  - [ ] (AC #1) Add an app-server capture mode to `scripts/generate-chat-transcripts.mjs`, invoking the worker with `PROXY_USE_APP_SERVER=true` and preserving metadata (CLI version, commit) via `buildMetadata()`.
  - [ ] (AC #1) Persist fixtures under `test-results/chat-completions/{proto,app}/` and ensure `tests/shared/transcript-utils.js` sanitizes IDs, timestamps, and tool handles for both backends.
  - [ ] (AC #1 Testing) Run `npm run generate:transcripts` to regenerate fixtures and confirm the repo diff only contains the paired outputs plus metadata updates.
- [ ] (AC #2) Implement parity diff automation and CI entry point
  - [ ] (AC #2) Create a diff harness (e.g., `tests/parity/chat-fixture-parity.test.mjs`) that walks both fixture trees, compares normalized payloads, and fails loudly on structural mismatches or missing files.
  - [ ] (AC #2) Expose an `npm run test:parity` script and add a CI job to execute it on PRs (P0) and nightly full runs (P1/P2).
  - [ ] (AC #2 Testing) Seed a deliberate mismatch locally to verify the harness surfaces actionable diagnostics, then revert and ensure clean runs pass.
- [ ] (AC #3) Refresh production-aligned baseline and document the process
  - [ ] (AC #3) Deploy the Epic 1 stack to the target environment, run smoke checks, and capture the exact CLI/app-server versions used for fixtures.
  - [ ] (AC #3) Document the capture workflow and deployment notes in `docs/openai-endpoint-golden-parity.md` (or linked runbook) so future refreshes remain consistent.
  - [ ] (AC #3 Testing) Attach smoke-test output (e.g., `npm run test:integration`, `npm test`) to the story to confirm the baseline is healthy prior to fixture capture.</tasks>
  </story>

  <acceptanceCriteria>1. Transcript capture tooling records paired proto and app-server outputs for baseline chat, streaming, tool-call, and error scenarios, normalizes dynamic fields, and stores version metadata with the fixtures. [Source](docs/epics.md#story-20-establish-parity-verification-infrastructure) [Source](docs/openai-endpoint-golden-parity.md#8-golden-transcripts-copy-ready)
2. A parity diff harness runs in CI, comparing the paired fixtures with clear diagnostics, failing when transcripts diverge or required scenarios are missing. [Source](docs/epics.md#story-20-establish-parity-verification-infrastructure)
3. The Epic 1 app-server baseline is deployed and smoke-tested, and the capture/deployment process is documented so fixtures reflect the production-ready behavior. [Source](docs/epics.md#story-20-establish-parity-verification-infrastructure) [Source](docs/app-server-migration/codex-completions-api-migration.md#tests)</acceptanceCriteria>

  <artifacts>
    <docs>- docs/epics.md#story-20-establish-parity-verification-infrastructure — "Epic scope, story intent, and downstream dependencies."
- docs/PRD.md#functional-requirements — "FR013 requires deterministic JSON-RPC mocks and transcripts."
- docs/openai-endpoint-golden-parity.md#8-golden-transcripts-copy-ready — "Step-by-step capture commands and canonical transcript shapes."
- docs/app-server-migration/codex-completions-api-migration.md#tests — "Migration runbook notes replacing proto shim with JSON-RPC mock."
- docs/architecture.md#epic-2--v1chatcompletions-json-rpc-parity — "Architecture constraints for single transport, concurrency, and observability."
- docs/test-design-epic-2.md — "Risk-based test plan covering parity fixtures, diff harness, and CI strategy."</docs>
    <code>- scripts/generate-chat-transcripts.mjs — "Capture orchestrator (see lines 1-200) running proto/app scenarios."
- tests/shared/transcript-utils.js — "Sanitizers + metadata helpers (lines 1-210) used for deterministic fixtures."
- tests/integration/helpers.js — "startServer/stopServer utilities (lines 1-120) reused by capture scripts."
- scripts/fake-codex-proto.js — "Proto shim for baseline responses (lines 1-140)."
- scripts/fake-codex-proto-no-complete.js — "Proto truncation shim (lines 1-60) for finish_reason coverage."
- tests/integration/chat.contract.nonstream.int.test.js — "Proto contract assertions to mirror (lines 1-160)."
- tests/integration/chat.contract.streaming.int.test.js — "Streaming contract coverage (lines 1-180)."
- tests/integration/json-rpc-transport.int.test.js — "Transport handshake verification (lines 1-160)."</code>
    <dependencies>- @openai/codex: 0.53.0
- node-fetch: ^3.3.2
- vitest: ^4.0.3
- @playwright/test: ^1.56.1</dependencies>
  </artifacts>

  <constraints>- Honor architecture guidance for a single JSON-RPC transport with bounded concurrency and shared observability.
- Capture fixtures using existing sanitizers (ID/timestamp/tool handles) to keep diffs deterministic.
- Record Codex CLI and app-server version metadata in every fixture; regenerate whenever versions drift.
- Persist outputs under `test-results/chat-completions/{proto,app}/` via `TRANSCRIPT_ROOT`.
- Run capture with `PROXY_USE_APP_SERVER=true` and ensure the worker is healthy before diffing.
- Document regeneration and deployment steps in parity guide/runbook for future refreshes.</constraints>
  <interfaces>- scripts/generate-chat-transcripts.mjs → `captureChatScenario`, `runCapture`
- tests/shared/transcript-utils.js → `buildMetadata`, `saveTranscript`, `sanitizeStreamTranscript`, `ensureTranscripts`
- tests/integration/helpers.js → `startServer`, `stopServer`, `wait`
- scripts/fake-codex-proto*.js → Proto worker shims used for baseline comparisons</interfaces>
  <tests>
    <standards>Follow Epic 2 test design (docs/test-design-epic-2.md), reuse existing parity guidance, and emit structured diff logs for CI triage.</standards>
    <locations>- tests/integration/
- tests/parity/
- tests/shared/</locations>
    <ideas>- AC#1: Golden fixture regeneration smoke (`npm run transcripts:generate`), ensuring proto/app JSON equality for baseline, streaming, tool-call, and error scenarios.
- AC#2: Parity diff harness suite (`npm run test:parity`) comparing paired fixtures with deliberate mismatch smoke.
- AC#3: Deployment verification script capturing CLI version and rerunning `npm run test:integration`, `npm test` against the refreshed baseline.</ideas>
  </tests>
</story-context>

